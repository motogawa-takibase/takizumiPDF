<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Editor & PNG Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lucide@0.344.0/dist/umd/lucide.min.js"></script>
    <style>
        .drop-zone { border: 2px dashed #cbd5e1; transition: all 0.3s ease; }
        .drop-zone.dragover { border-color: #3b82f6; background-color: #eff6ff; }
        canvas { max-width: 100%; height: auto !important; display: block; }
        .editor-container { position: relative; display: inline-block; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); }
        .drawing-layer { position: absolute; top: 0; left: 0; pointer-events: auto; z-index: 10; cursor: crosshair; }
        
        .text-input-area { 
            position: absolute; 
            background: white; 
            border: 2px solid #3b82f6; 
            outline: none; 
            padding: 4px 8px; 
            font-size: 16px; 
            line-height: 1.5;
            min-width: 150px; 
            min-height: 40px;
            z-index: 100;
            border-radius: 4px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            resize: both;
            overflow: hidden;
            font-family: sans-serif;
        }

        .tool-btn.active { background-color: white; box-shadow: 0 1px 2px rgba(0,0,0,0.1); color: #2563eb; }
        .color-btn { position: relative; transition: transform 0.2s; border: 2px solid transparent; }
        .color-btn:hover { transform: scale(1.1); }
        .color-btn.active { border-color: #94a3b8; }
        .color-btn.active::after {
            content: '✓';
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-size: 12px; font-weight: bold;
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
        }
        button:disabled { opacity: 0.3; cursor: not-allowed; }
    </style>
</head>
<body class="bg-slate-100 min-h-screen text-slate-800 pb-20">

    <header class="bg-white border-b sticky top-0 z-50 px-6 py-3 flex flex-wrap items-center justify-between gap-4">
        <div class="flex items-center gap-2">
            <div class="bg-blue-600 p-1.5 rounded-lg text-white">
                <i data-lucide="file-edit"></i>
            </div>
            <h1 class="text-xl font-bold text-slate-900 hidden sm:block">PDF Editor & PNG</h1>
        </div>

        <div id="toolbar" class="hidden flex flex-wrap items-center gap-3">
            <div class="flex bg-slate-100 p-1 rounded-lg gap-1 border">
                <button id="btnUndo" class="p-2 rounded-md hover:bg-white hover:shadow-sm transition-all" title="元に戻す (Ctrl+Z)">
                    <i data-lucide="undo-2"></i>
                </button>
                <button id="btnRedo" class="p-2 rounded-md hover:bg-white hover:shadow-sm transition-all" title="やり直し (Ctrl+Y)">
                    <i data-lucide="redo-2"></i>
                </button>
            </div>

            <div class="flex bg-slate-100 p-1 rounded-lg gap-1 shadow-inner border">
                <button id="btnSelect" class="tool-btn p-2 rounded-md transition-all" title="選択・移動">
                    <i data-lucide="mouse-pointer-2"></i>
                </button>
                <button id="btnDraw" class="tool-btn active p-2 rounded-md transition-all" title="手書き">
                    <i data-lucide="pencil"></i>
                </button>
                <button id="btnRect" class="tool-btn p-2 rounded-md transition-all" title="四角形">
                    <i data-lucide="square"></i>
                </button>
                <button id="btnArrow" class="tool-btn p-2 rounded-md transition-all" title="矢印">
                    <i data-lucide="arrow-up-right"></i>
                </button>
                <button id="btnText" class="tool-btn p-2 rounded-md transition-all" title="テキスト">
                    <i data-lucide="type"></i>
                </button>
                <button id="btnArrowText" class="tool-btn p-2 rounded-md transition-all" title="矢印付きテキスト">
                    <i data-lucide="message-square"></i>
                </button>
            </div>

            <div class="flex bg-slate-100 p-1 rounded-lg gap-2 px-2 items-center border">
                <button class="color-btn active w-7 h-7 rounded-full bg-black shadow-inner" data-color="#000000"></button>
                <button class="color-btn w-7 h-7 rounded-full bg-red-600 shadow-inner" data-color="#e11d48"></button>
                <button class="color-btn w-7 h-7 rounded-full bg-blue-600 shadow-inner" data-color="#2563eb"></button>
                <button class="color-btn w-7 h-7 rounded-full bg-green-600 shadow-inner" data-color="#16a34a"></button>
            </div>

            <button id="btnDelete" class="p-2 text-red-500 hover:bg-red-50 rounded-md hidden border border-transparent hover:border-red-200 transition-colors">
                <i data-lucide="trash-2"></i>
            </button>

            <div class="h-6 w-px bg-slate-300"></div>
            
            <button id="savePdf" class="bg-slate-800 text-white px-4 py-1.5 rounded-md text-sm font-bold flex items-center gap-2 hover:bg-slate-700">
                <i data-lucide="download"></i> PDF保存
            </button>
            <button id="exportPng" class="bg-blue-600 text-white px-4 py-1.5 rounded-md text-sm font-bold flex items-center gap-2 hover:bg-blue-700">
                <i data-lucide="image"></i> PNG変換
            </button>
        </div>

        <button onclick="location.reload()" class="text-slate-500 hover:text-slate-800 p-2">
            <i data-lucide="rotate-ccw"></i>
        </button>
    </header>

    <main class="max-w-5xl mx-auto p-6 text-center">
        <div id="uploadView" class="mt-10">
            <div id="dropZone" class="drop-zone bg-white rounded-2xl p-20 text-center cursor-pointer shadow-sm hover:shadow-md transition-all">
                <input type="file" id="fileInput" class="hidden" accept="application/pdf">
                <div class="flex flex-col items-center">
                    <div class="bg-blue-50 p-6 rounded-full mb-6">
                        <i data-lucide="upload-cloud" class="h-12 w-12 text-blue-500"></i>
                    </div>
                    <p class="text-2xl font-bold text-slate-800 mb-2">PDFを読み込む</p>
                    <p class="text-slate-500">ファイルをドロップするかクリック</p>
                </div>
            </div>
        </div>

        <div id="editorView" class="hidden flex flex-col items-center gap-4">
            <div class="flex items-center gap-4 justify-center py-2 bg-white px-6 rounded-full shadow-sm">
                <button id="prevPage" class="p-1 rounded-full hover:bg-slate-100"><i data-lucide="chevron-left"></i></button>
                <span class="font-bold text-slate-700">ページ <span id="pageNum">1</span> / <span id="pageCount">1</span></span>
                <button id="nextPage" class="p-1 rounded-full hover:bg-slate-100"><i data-lucide="chevron-right"></i></button>
            </div>

            <div id="canvasContainer" class="editor-container">
                <canvas id="pdfCanvas"></canvas>
                <canvas id="drawingLayer" class="drawing-layer"></canvas>
                <div id="textLayer" class="absolute inset-0 pointer-events-none z-20"></div>
            </div>
            <p class="text-sm text-slate-500 mt-2">ツールを選択してドラッグで描画、選択モードで要素や矢印の先を移動できます。</p>
        </div>
    </main>

    <div id="toast" class="fixed bottom-10 left-1/2 -translate-x-1/2 bg-slate-900 text-white px-6 py-3 rounded-full shadow-2xl transition-all duration-300 opacity-0 translate-y-10 pointer-events-none z-[100]">
        <span id="toastMsg"></span>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        lucide.createIcons();

        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('dropZone');
        const editorView = document.getElementById('editorView');
        const uploadView = document.getElementById('uploadView');
        const toolbar = document.getElementById('toolbar');
        const canvasContainer = document.getElementById('canvasContainer');
        const pdfCanvas = document.getElementById('pdfCanvas');
        const drawingLayer = document.getElementById('drawingLayer');
        const textLayer = document.getElementById('textLayer');
        const drawCtx = drawingLayer.getContext('2d');
        const btnDelete = document.getElementById('btnDelete');
        const btnUndo = document.getElementById('btnUndo');
        const btnRedo = document.getElementById('btnRedo');
        
        let currentPdf = null;
        let pdfBytes = null;
        let currentPageNum = 1;
        let isMouseDown = false;
        let isDragging = false;
        let dragMode = 'move'; // 'move' (全体) or 'endpoint' (矢印の先)
        let startX, startY;
        let mode = 'draw'; 
        let currentColor = '#000000';
        let pageData = {}; 
        let history = {};  
        let historyIndex = {}; 
        
        let selectedElement = null;

        const TEXT_WIDTH = 150; 

        function saveHistory() {
            const p = currentPageNum;
            if (!history[p]) { history[p] = []; historyIndex[p] = -1; }
            history[p] = history[p].slice(0, historyIndex[p] + 1);
            history[p].push(JSON.stringify(pageData[p]));
            historyIndex[p]++;
            if (history[p].length > 50) { history[p].shift(); historyIndex[p]--; }
            updateHistoryButtons();
        }

        function undo() {
            const p = currentPageNum;
            if (historyIndex[p] > 0) {
                historyIndex[p]--;
                pageData[p] = JSON.parse(history[p][historyIndex[p]]);
                selectedElement = null;
                updateDeleteButton();
                redrawCanvas();
                updateHistoryButtons();
            }
        }

        function redo() {
            const p = currentPageNum;
            if (history[p] && historyIndex[p] < history[p].length - 1) {
                historyIndex[p]++;
                pageData[p] = JSON.parse(history[p][historyIndex[p]]);
                selectedElement = null;
                updateDeleteButton();
                redrawCanvas();
                updateHistoryButtons();
            }
        }

        function updateHistoryButtons() {
            const p = currentPageNum;
            btnUndo.disabled = !(historyIndex[p] > 0);
            btnRedo.disabled = !(history[p] && historyIndex[p] < history[p].length - 1);
        }

        function getCanvasCoordinates(e) {
            const rect = drawingLayer.getBoundingClientRect();
            const scaleX = drawingLayer.width / rect.width;
            const scaleY = drawingLayer.height / rect.height;
            return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
        }

        dropZone.onclick = () => fileInput.click();
        dropZone.ondragover = (e) => { e.preventDefault(); dropZone.classList.add('dragover'); };
        dropZone.ondrop = (e) => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file?.type === 'application/pdf') loadPdf(file);
        };
        fileInput.onchange = (e) => { if (e.target.files[0]) loadPdf(e.target.files[0]); };

        async function loadPdf(file) {
            const reader = new FileReader();
            reader.onload = async function() {
                pdfBytes = new Uint8Array(this.result);
                currentPdf = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
                uploadView.classList.add('hidden');
                editorView.classList.remove('hidden');
                toolbar.classList.remove('hidden');
                document.getElementById('pageCount').textContent = currentPdf.numPages;
                renderPage(1);
            };
            reader.readAsArrayBuffer(file);
        }

        async function renderPage(num) {
            currentPageNum = num;
            document.getElementById('pageNum').textContent = num;
            const page = await currentPdf.getPage(num);
            const viewport = page.getViewport({ scale: 1.5 });
            pdfCanvas.height = viewport.height;
            pdfCanvas.width = viewport.width;
            drawingLayer.height = viewport.height;
            drawingLayer.width = viewport.width;
            await page.render({ canvasContext: pdfCanvas.getContext('2d'), viewport }).promise;
            if (!pageData[num]) { pageData[num] = []; saveHistory(); }
            selectedElement = null;
            updateDeleteButton();
            updateHistoryButtons();
            redrawCanvas();
        }

        function drawArrow(ctx, x1, y1, x2, y2, color) {
            const headlen = 15;
            const angle = Math.atan2(y2 - y1, x2 - x1);
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }

        drawingLayer.onmousedown = (e) => {
            const coords = getCanvasCoordinates(e);
            startX = coords.x;
            startY = coords.y;

            if (document.querySelector('.text-input-area')) return;

            if (mode === 'select') {
                const hit = findElementWithHandleAt(startX, startY);
                if (hit) {
                    selectedElement = hit.element;
                    dragMode = hit.handle; 
                    isMouseDown = true;
                    isDragging = false; 
                } else { 
                    selectedElement = null; 
                }
                updateDeleteButton();
                redrawCanvas();
                return;
            }

            if (mode === 'text') { addTextInput(startX, startY); return; }

            isMouseDown = true;
            dragMode = 'move';
            if (mode === 'draw') {
                pageData[currentPageNum].push({ type: 'draw', points: [{ x: startX, y: startY }], color: currentColor });
            } else if (mode === 'rect') {
                pageData[currentPageNum].push({ type: 'rect', x: startX, y: startY, w: 0, h: 0, color: currentColor });
            } else if (mode === 'arrow' || mode === 'arrowtext') {
                pageData[currentPageNum].push({ type: mode, x: startX, y: startY, x2: startX, y2: startY, color: currentColor, text: '' });
            }
        };

        drawingLayer.onmousemove = (e) => {
            if (!isMouseDown) return;
            const coords = getCanvasCoordinates(e);
            const currX = coords.x;
            const currY = coords.y;

            if (mode === 'select' && selectedElement) {
                isDragging = true;
                if (dragMode === 'endpoint') {
                    selectedElement.x2 = currX;
                    selectedElement.y2 = currY;
                } else {
                    const dx = currX - startX;
                    const dy = currY - startY;
                    if (selectedElement.type === 'draw') {
                        selectedElement.points.forEach(p => { p.x += dx; p.y += dy; });
                    } else if (selectedElement.type === 'arrow' || selectedElement.type === 'arrowtext') {
                        selectedElement.x += dx; selectedElement.y += dy;
                        selectedElement.x2 += dx; selectedElement.y2 += dy;
                    } else {
                        selectedElement.x += dx;
                        selectedElement.y += dy;
                    }
                }
                startX = currX; startY = currY;
                redrawCanvas();
                return;
            }

            const currentList = pageData[currentPageNum];
            const activeObj = currentList[currentList.length - 1];

            if (mode === 'draw') { activeObj.points.push({ x: currX, y: currY }); } 
            else if (mode === 'rect') { activeObj.w = currX - startX; activeObj.h = currY - startY; } 
            else if (mode === 'arrow' || mode === 'arrowtext') { activeObj.x2 = currX; activeObj.y2 = currY; }
            redrawCanvas();
        };

        drawingLayer.onmouseup = () => {
            if (isMouseDown) {
                if (mode !== 'select' || isDragging) {
                    const list = pageData[currentPageNum];
                    const activeObj = list[list.length - 1];
                    if (mode === 'arrowtext' && !isDragging) {
                        addTextInput(activeObj.x, activeObj.y, activeObj);
                    } else {
                        saveHistory();
                    }
                }
            }
            isMouseDown = false;
            isDragging = false;
        };

        function findElementWithHandleAt(x, y) {
            const list = pageData[currentPageNum];
            const tolerance = 20; 

            for (let i = list.length - 1; i >= 0; i--) {
                const el = list[i];
                
                if (el.type === 'arrow' || el.type === 'arrowtext') {
                    const distEnd = Math.hypot(el.x2 - x, el.y2 - y);
                    if (distEnd < tolerance) return { element: el, handle: 'endpoint' };
                }

                if (el.type === 'rect') {
                    const left = Math.min(el.x, el.x + (el.w||0)) - 10;
                    const right = Math.max(el.x, el.x + (el.w||0)) + 10;
                    const top = Math.min(el.y, el.y + (el.h||0)) - 10;
                    const bottom = Math.max(el.y, el.y + (el.h||0)) + 10;
                    if (x >= left && x <= right && y >= top && y <= bottom) return { element: el, handle: 'move' };
                } else if (el.type === 'text') {
                    const lines = (el.text || "").split('\n');
                    const width = TEXT_WIDTH; const height = lines.length * 24 + 10;
                    if (x >= el.x - 10 && x <= el.x + width && y >= el.y - 10 && y <= el.y + height) return { element: el, handle: 'move' };
                } else if (el.type === 'arrowtext') {
                    const lines = (el.text || "").split('\n');
                    const width = TEXT_WIDTH; const height = lines.length * 24 + 10;
                    if (x >= el.x - 10 && x <= el.x + width && y >= el.y - 10 && y <= el.y + height) return { element: el, handle: 'move' };
                    const pts = getArrowTextPoints(el);
                    if (isPointNearLine(x, y, pts.x1, pts.y1, pts.x2, pts.y2)) return { element: el, handle: 'move' };
                } else if (el.type === 'arrow') {
                    if (isPointNearLine(x, y, el.x, el.y, el.x2, el.y2)) return { element: el, handle: 'move' };
                } else if (el.type === 'draw') {
                    if (el.points.some(p => Math.hypot(p.x - x, p.y - y) < tolerance)) return { element: el, handle: 'move' };
                }
            }
            return null;
        }

        function isPointNearLine(px, py, x1, y1, x2, y2) {
            const L2 = (x2 - x1)**2 + (y2 - y1)**2;
            if (L2 === 0) return Math.hypot(px - x1, py - y1) < 15;
            let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / L2;
            t = Math.max(0, Math.min(1, t));
            const dist = Math.hypot(px - (x1 + t * (x2 - x1)), py - (y1 + t * (y2 - y1)));
            return dist < 15;
        }

        function getArrowTextPoints(el) {
            const lines = (el.text || "").split('\n');
            const h = lines.length * 24 + 8;
            const w = TEXT_WIDTH;
            
            const boxLeft = el.x;
            const boxRight = el.x + w;
            const boxTop = el.y;
            const boxBottom = el.y + h;
            const boxCenterX = el.x + w / 2;
            const boxCenterY = el.y + h / 2;

            // ターゲット（終点）の座標
            const tx = el.x2;
            const ty = el.y2;

            let startPointX, startPointY;

            // ボックスの4辺のどこが一番ターゲットに近いか（または領域的にどこにあるか）を判定
            // 簡易的に角度または距離の比較で行う
            const dx = tx - boxCenterX;
            const dy = ty - boxCenterY;

            // ボックスの縦横比に基づいた境界判定
            // abs(dx)/w と abs(dy)/h を比較してどちらの面に近いか決める
            if (Math.abs(dx) / w > Math.abs(dy) / h) {
                // 左右のいずれか
                startPointY = boxCenterY;
                startPointX = (dx > 0) ? boxRight : boxLeft;
            } else {
                // 上下のいずれか
                startPointX = boxCenterX;
                startPointY = (dy > 0) ? boxBottom : boxTop;
            }

            return { x1: startPointX, y1: startPointY, x2: el.x2, y2: el.y2 };
        }

        function redrawCanvas() {
            drawCtx.clearRect(0, 0, drawingLayer.width, drawingLayer.height);
            textLayer.innerHTML = '';
            const rect = drawingLayer.getBoundingClientRect();
            const cssScaleX = rect.width / drawingLayer.width;
            const cssScaleY = rect.height / drawingLayer.height;

            pageData[currentPageNum].forEach(el => {
                const isSelected = (el === selectedElement);
                drawCtx.strokeStyle = el.color;
                drawCtx.lineWidth = 3;
                drawCtx.lineCap = 'round';
                drawCtx.lineJoin = 'round';

                if (el.type === 'draw') {
                    drawCtx.beginPath();
                    el.points.forEach((p, idx) => { if (idx === 0) drawCtx.moveTo(p.x, p.y); else drawCtx.lineTo(p.x, p.y); });
                    drawCtx.stroke();
                } else if (el.type === 'rect') {
                    drawCtx.strokeRect(el.x, el.y, el.w, el.h);
                } else if (el.type === 'arrow') {
                    drawArrow(drawCtx, el.x, el.y, el.x2, el.y2, el.color);
                } else if (el.type === 'arrowtext') {
                    const pts = getArrowTextPoints(el);
                    drawArrow(drawCtx, pts.x1, pts.y1, pts.x2, pts.y2, el.color);
                }

                if (el.type === 'text' || el.type === 'arrowtext') {
                    const div = document.createElement('div');
                    div.style.position = 'absolute';
                    div.style.left = (el.x * cssScaleX) + 'px';
                    div.style.top = (el.y * cssScaleY) + 'px';
                    div.style.width = (TEXT_WIDTH * cssScaleX) + 'px';
                    div.style.pointerEvents = 'none';
                    div.style.whiteSpace = 'pre-wrap';
                    div.textContent = el.text;
                    div.style.fontSize = '16px';
                    div.style.lineHeight = '1.5';
                    div.style.fontWeight = '500';
                    div.style.color = el.color;
                    div.style.fontFamily = 'sans-serif';
                    if (isSelected) {
                        div.style.outline = '2px dashed #3b82f6';
                        div.style.outlineOffset = '4px';
                        div.style.backgroundColor = 'rgba(59, 130, 246, 0.1)';
                    }
                    textLayer.appendChild(div);
                }

                if (isSelected) {
                    drawSelectionOverlay(el);
                }
            });
        }

        function drawSelectionOverlay(el) {
            drawCtx.save();
            drawCtx.setLineDash([8, 4]);
            drawCtx.strokeStyle = '#3b82f6';
            drawCtx.lineWidth = 2;
            
            if (el.type === 'arrow' || el.type === 'arrowtext') {
                drawCtx.setLineDash([]);
                drawCtx.fillStyle = 'white';
                drawCtx.beginPath();
                drawCtx.arc(el.x2, el.y2, 6, 0, Math.PI * 2);
                drawCtx.fill();
                drawCtx.stroke();
                drawCtx.setLineDash([8, 4]);
            }

            if (el.type !== 'text' && el.type !== 'arrowtext') {
                let minX, minY, w, h;
                if (el.type === 'draw') {
                    minX = Math.min(...el.points.map(p => p.x));
                    const maxX = Math.max(...el.points.map(p => p.x));
                    minY = Math.min(...el.points.map(p => p.y));
                    const maxY = Math.max(...el.points.map(p => p.y));
                    w = maxX - minX; h = maxY - minY;
                } else if (el.type === 'arrow') {
                    minX = Math.min(el.x, el.x2); minY = Math.min(el.y, el.y2);
                    w = Math.abs(el.x2 - el.x); h = Math.abs(el.y2 - el.y);
                } else {
                    minX = el.x; minY = el.y; w = el.w || 0; h = el.h || 0;
                }
                drawCtx.strokeRect(minX - 10, minY - 10, w + 20, h + 20);
            }
            drawCtx.restore();
        }

        function updateDeleteButton() {
            if (selectedElement) btnDelete.classList.remove('hidden');
            else btnDelete.classList.add('hidden');
        }

        btnDelete.onclick = () => {
            if (selectedElement) {
                const list = pageData[currentPageNum];
                const idx = list.indexOf(selectedElement);
                if (idx > -1) { list.splice(idx, 1); saveHistory(); }
                selectedElement = null; updateDeleteButton(); redrawCanvas();
            }
        };

        btnUndo.onclick = undo;
        btnRedo.onclick = redo;

        window.onkeydown = (e) => {
            if ((e.ctrlKey || e.metaKey)) {
                if (e.key === 'z') { e.preventDefault(); if (e.shiftKey) redo(); else undo(); }
                else if (e.key === 'y') { e.preventDefault(); redo(); }
            }
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedElement) {
                if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                    btnDelete.click();
                }
            }
        };

        function addTextInput(x, y, targetObj = null) {
            const rect = drawingLayer.getBoundingClientRect();
            const cssScaleX = rect.width / drawingLayer.width;
            const cssScaleY = rect.height / drawingLayer.height;
            const textarea = document.createElement('textarea');
            textarea.placeholder = '内容を入力...';
            textarea.className = 'text-input-area';
            
            textarea.style.left = (x * cssScaleX) + 'px';
            textarea.style.top = (y * cssScaleY) + 'px'; 
            textarea.style.width = (TEXT_WIDTH * cssScaleX) + 'px';
            textarea.style.color = currentColor;
            canvasContainer.appendChild(textarea);
            setTimeout(() => textarea.focus(), 10);

            let isFinalized = false;
            const finalize = () => {
                if (isFinalized) return;
                isFinalized = true;
                const val = textarea.value.trim();
                if (val) {
                    if (targetObj) {
                        targetObj.text = val;
                        targetObj.x = x; targetObj.y = y;
                    } else {
                        pageData[currentPageNum].push({ type: 'text', text: val, x: x, y: y, x2: x, y2: y, color: currentColor });
                    }
                    saveHistory();
                    redrawCanvas();
                } else if (targetObj && targetObj.type === 'arrowtext') {
                    const list = pageData[currentPageNum];
                    const idx = list.indexOf(targetObj);
                    if (idx > -1) list.splice(idx, 1);
                    redrawCanvas();
                }
                if (textarea.parentNode) textarea.parentNode.removeChild(textarea);
            };
            textarea.onblur = finalize;
            textarea.onkeydown = (e) => { 
                if(e.key === 'Enter' && (e.ctrlKey || e.metaKey)) finalize();
                if(e.key === 'Escape') { isFinalized = true; textarea.remove(); }
            };
        }

        const buttons = {
            select: document.getElementById('btnSelect'),
            draw: document.getElementById('btnDraw'),
            rect: document.getElementById('btnRect'),
            arrow: document.getElementById('btnArrow'),
            text: document.getElementById('btnText'),
            arrowtext: document.getElementById('btnArrowText')
        };

        Object.keys(buttons).forEach(key => {
            buttons[key].onclick = () => {
                mode = key; selectedElement = null; updateDeleteButton();
                Object.values(buttons).forEach(b => b.classList.remove('active'));
                buttons[key].classList.add('active');
                redrawCanvas();
            };
        });

        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.onclick = () => {
                currentColor = btn.dataset.color;
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                if (selectedElement) { selectedElement.color = currentColor; saveHistory(); redrawCanvas(); }
            };
        });

        document.getElementById('prevPage').onclick = () => { if (currentPageNum > 1) renderPage(currentPageNum - 1); };
        document.getElementById('nextPage').onclick = () => { if (currentPageNum < currentPdf.numPages) renderPage(currentPageNum + 1); };

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return { r, g, b };
        }

        document.getElementById('savePdf').onclick = async () => {
            showToast("PDFを生成中...");
            try {
                const { PDFDocument, rgb, StandardFonts } = PDFLib;
                const pdfDoc = await PDFDocument.load(pdfBytes);
                const pages = pdfDoc.getPages();
                const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
                for (let i = 0; i < pages.length; i++) {
                    const pNum = i + 1;
                    if (!pageData[pNum]) continue;
                    const page = pages[i];
                    const { width, height } = page.getSize();
                    const sX = width / pdfCanvas.width;
                    const sY = height / pdfCanvas.height;
                    pageData[pNum].forEach(el => {
                        const c = hexToRgb(el.color);
                        const pdfColor = rgb(c.r, c.g, c.b);
                        if (el.type === 'draw') {
                            for (let j = 1; j < el.points.length; j++) {
                                page.drawLine({ start: { x: el.points[j-1].x * sX, y: height - (el.points[j-1].y * sY) }, end: { x: el.points[j].x * sX, y: height - (el.points[j].y * sY) }, thickness: 2, color: pdfColor });
                            }
                        } else if (el.type === 'rect') {
                            page.drawRectangle({ x: el.x * sX, y: height - (el.y * sY) - (el.h * sY), width: el.w * sX, height: el.h * sY, borderWidth: 2, borderColor: pdfColor });
                        } else if (el.type === 'arrow') {
                            page.drawLine({ start: { x: el.x * sX, y: height - (el.y * sY) }, end: { x: el.x2 * sX, y: height - (el.y2 * sY) }, thickness: 2, color: pdfColor });
                        } else if (el.type === 'arrowtext') {
                            const pts = getArrowTextPoints(el);
                            page.drawLine({ start: { x: pts.x1 * sX, y: height - (pts.y1 * sY) }, end: { x: pts.x2 * sX, y: height - (pts.y2 * sY) }, thickness: 2, color: pdfColor });
                        }
                        
                        if (el.text) {
                            const lines = el.text.split('\n');
                            lines.forEach((line, idx) => {
                                page.drawText(line, { x: el.x * sX, y: height - (el.y * sY) - (14 * sY) - (idx * 18 * sY), size: 14 * sY, font: font, color: pdfColor });
                            });
                        }
                    });
                }
                const pdfData = await pdfDoc.save();
                const blob = new Blob([pdfData], { type: 'application/pdf' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob); a.download = "edited.pdf"; a.click();
                showToast("PDFを保存しました");
            } catch (e) { console.error(e); showToast("保存失敗"); }
        };

        document.getElementById('exportPng').onclick = () => {
            const temp = document.createElement('canvas');
            temp.width = pdfCanvas.width; temp.height = pdfCanvas.height;
            const ctx = temp.getContext('2d');
            ctx.drawImage(pdfCanvas, 0, 0);
            const oldSelected = selectedElement;
            selectedElement = null; redrawCanvas();
            ctx.drawImage(drawingLayer, 0, 0);
            pageData[currentPageNum].forEach(el => {
                if (el.text) {
                    ctx.fillStyle = el.color; ctx.font = "16px sans-serif";
                    const lines = el.text.split('\n');
                    lines.forEach((line, idx) => { ctx.fillText(line, el.x, el.y + 16 + (idx * 24)); });
                }
            });
            selectedElement = oldSelected; redrawCanvas();
            const link = document.createElement('a');
            link.download = `page_${currentPageNum}.png`; link.href = temp.toDataURL('image/png'); link.click();
        };

        function showToast(msg) {
            const t = document.getElementById('toast');
            document.getElementById('toastMsg').textContent = msg;
            t.classList.remove('opacity-0', 'translate-y-10');
            setTimeout(() => t.classList.add('opacity-0', 'translate-y-10'), 3000);
        }
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Editor & PNG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .drop-zone { border: 2px dashed #cbd5e1; transition: all 0.3s ease; }
        .drop-zone.dragover { border-color: #3b82f6; background-color: #eff6ff; }
        canvas { max-width: 100%; height: auto !important; display: block; }
        .editor-container { position: relative; display: inline-block; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); }
        .drawing-layer { position: absolute; top: 0; left: 0; pointer-events: auto; z-index: 10; cursor: crosshair; }
        .text-input-area { 
            position: absolute; background: white; border: 2px solid #3b82f6; 
            outline: none; padding: 4px 8px; font-size: 16px; line-height: 1.5;
            min-width: 150px; min-height: 40px; z-index: 100; border-radius: 4px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); resize: both; overflow: hidden; font-family: sans-serif;
        }
        .tool-btn.active { background-color: white; box-shadow: 0 1px 2px rgba(0,0,0,0.1); color: #2563eb; }
        .color-btn { position: relative; transition: transform 0.2s; border: 2px solid transparent; }
        .color-btn.active { border-color: #94a3b8; }
        .color-btn.active::after { content: '✓'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 12px; font-weight: bold; text-shadow: 0 0 2px rgba(0,0,0,0.5); }
    </style>
</head>
<body class="bg-slate-100 min-h-screen text-slate-800 pb-20">

    <div id="appRoot">
        <header class="bg-white border-b sticky top-0 z-50 px-6 py-3 flex flex-wrap items-center justify-between gap-4">
            <div class="flex items-center gap-2">
                <div class="bg-blue-600 p-1.5 rounded-lg text-white"><i data-lucide="file-edit"></i></div>
                <h1 class="text-xl font-bold text-slate-900 hidden sm:block">PDF Editor & PNG</h1>
            </div>
            <div id="toolbar" class="hidden flex flex-wrap items-center gap-3">
                <div class="flex bg-slate-100 p-1 rounded-lg gap-1 border">
                    <button id="btnUndo" class="p-2 rounded-md hover:bg-white hover:shadow-sm transition-all" title="Undo"><i data-lucide="undo-2"></i></button>
                    <button id="btnRedo" class="p-2 rounded-md hover:bg-white hover:shadow-sm transition-all" title="Redo"><i data-lucide="redo-2"></i></button>
                </div>
                <div class="flex bg-slate-100 p-1 rounded-lg gap-1 shadow-inner border">
                    <button id="btnSelect" class="tool-btn p-2 rounded-md transition-all" title="Select"><i data-lucide="mouse-pointer-2"></i></button>
                    <button id="btnDraw" class="tool-btn active p-2 rounded-md transition-all" title="Draw"><i data-lucide="pencil"></i></button>
                    <button id="btnRect" class="tool-btn p-2 rounded-md transition-all" title="Rect"><i data-lucide="square"></i></button>
                    <button id="btnArrow" class="tool-btn p-2 rounded-md transition-all" title="Arrow"><i data-lucide="arrow-up-right"></i></button>
                    <button id="btnText" class="tool-btn p-2 rounded-md transition-all" title="Text"><i data-lucide="type"></i></button>
                    <button id="btnArrowText" class="tool-btn p-2 rounded-md transition-all" title="Arrow Text"><i data-lucide="message-square"></i></button>
                </div>
                <div class="flex bg-slate-100 p-1 rounded-lg gap-2 px-2 items-center border">
                    <button class="color-btn active w-7 h-7 rounded-full bg-black shadow-inner" data-color="#000000"></button>
                    <button class="color-btn w-7 h-7 rounded-full bg-red-600 shadow-inner" data-color="#e11d48"></button>
                    <button class="color-btn w-7 h-7 rounded-full bg-blue-600 shadow-inner" data-color="#2563eb"></button>
                    <button class="color-btn w-7 h-7 rounded-full bg-green-600 shadow-inner" data-color="#16a34a"></button>
                </div>
                <button id="btnDelete" class="p-2 text-red-500 hover:bg-red-50 rounded-md hidden border border-transparent hover:border-red-200 transition-colors"><i data-lucide="trash-2"></i></button>
                <div class="h-6 w-px bg-slate-300"></div>
                <button id="savePdf" class="bg-slate-800 text-white px-4 py-1.5 rounded-md text-sm font-bold flex items-center gap-2 hover:bg-slate-700"><i data-lucide="download"></i> PDF保存</button>
                <button id="exportPng" class="bg-blue-600 text-white px-4 py-1.5 rounded-md text-sm font-bold flex items-center gap-2 hover:bg-blue-700"><i data-lucide="image"></i> PNG変換</button>
            </div>
        </header>

        <main class="max-w-5xl mx-auto p-6 text-center">
            <!-- ここが初期画面（アップロード用） -->
            <div id="uploadView" class="mt-10">
                <div id="dropZone" class="drop-zone bg-white rounded-2xl p-20 text-center cursor-pointer shadow-sm hover:shadow-md transition-all">
                    <input type="file" id="fileInput" class="hidden" accept="application/pdf">
                    <div class="flex flex-col items-center">
                        <div class="bg-blue-50 p-6 rounded-full mb-6"><i data-lucide="upload-cloud" class="h-12 w-12 text-blue-500"></i></div>
                        <p class="text-2xl font-bold text-slate-800 mb-2">PDFを読み込む</p>
                        <p class="text-slate-500">ファイルをドロップするかクリック</p>
                    </div>
                </div>
            </div>
            <!-- ここが編集画面（最初は非表示） -->
            <div id="editorView" class="hidden flex flex-col items-center gap-4">
                <div class="flex items-center gap-4 justify-center py-2 bg-white px-6 rounded-full shadow-sm">
                    <button id="prevPage" class="p-1 rounded-full hover:bg-slate-100"><i data-lucide="chevron-left"></i></button>
                    <span class="font-bold text-slate-700">ページ <span id="pageNum">1</span> / <span id="pageCount">1</span></span>
                    <button id="nextPage" class="p-1 rounded-full hover:bg-slate-100"><i data-lucide="chevron-right"></i></button>
                </div>
                <div id="canvasContainer" class="editor-container">
                    <canvas id="pdfCanvas"></canvas>
                    <canvas id="drawingLayer" class="drawing-layer"></canvas>
                    <div id="textLayer" class="absolute inset-0 pointer-events-none z-20"></div>
                </div>
            </div>
        </main>
    </div>

    <!-- ライブラリ読み込み -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lucide@0.344.0/dist/umd/lucide.min.js"></script>

    <script>
        // アイコン初期化
        lucide.createIcons();

        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('dropZone');
        const editorView = document.getElementById('editorView');
        const uploadView = document.getElementById('uploadView');
        const toolbar = document.getElementById('toolbar');
        const canvasContainer = document.getElementById('canvasContainer');
        const pdfCanvas = document.getElementById('pdfCanvas');
        const drawingLayer = document.getElementById('drawingLayer');
        const textLayer = document.getElementById('textLayer');
        const drawCtx = drawingLayer.getContext('2d');
        const btnDelete = document.getElementById('btnDelete');
        const btnUndo = document.getElementById('btnUndo');
        const btnRedo = document.getElementById('btnRedo');

        let currentPdf = null;
        let pdfBytes = null;
        let currentPageNum = 1;
        let isMouseDown = false;
        let isDragging = false;
        let dragMode = 'move';
        let startX, startY;
        let mode = 'draw'; 
        let currentColor = '#000000';
        let pageData = {}; 
        let history = {};  
        let historyIndex = {}; 
        let selectedElement = null;
        const TEXT_WIDTH = 150;

        function saveHistory() {
            const p = currentPageNum;
            if (!history[p]) { history[p] = []; historyIndex[p] = -1; }
            history[p] = history[p].slice(0, historyIndex[p] + 1);
            history[p].push(JSON.stringify(pageData[p]));
            historyIndex[p]++;
            updateHistoryButtons();
        }

        function undo() {
            const p = currentPageNum;
            if (historyIndex[p] > 0) {
                historyIndex[p]--;
                pageData[p] = JSON.parse(history[p][historyIndex[p]]);
                selectedElement = null; redrawCanvas(); updateHistoryButtons();
            }
        }

        function redo() {
            const p = currentPageNum;
            if (history[p] && historyIndex[p] < history[p].length - 1) {
                historyIndex[p]++;
                pageData[p] = JSON.parse(history[p][historyIndex[p]]);
                selectedElement = null; redrawCanvas(); updateHistoryButtons();
            }
        }

        function updateHistoryButtons() {
            const p = currentPageNum;
            btnUndo.disabled = !(historyIndex[p] > 0);
            btnRedo.disabled = !(history[p] && historyIndex[p] < history[p].length - 1);
        }

        function getCanvasCoordinates(e) {
            const rect = drawingLayer.getBoundingClientRect();
            const scaleX = drawingLayer.width / rect.width;
            const scaleY = drawingLayer.height / rect.height;
            return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
        }

        dropZone.onclick = () => fileInput.click();
        dropZone.ondragover = (e) => { e.preventDefault(); dropZone.classList.add('dragover'); };
        dropZone.ondrop = (e) => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file?.type === 'application/pdf') loadPdf(file);
        };
        fileInput.onchange = (e) => { if (e.target.files[0]) loadPdf(e.target.files[0]); };

        async function loadPdf(file) {
            const reader = new FileReader();
            reader.onload = async function() {
                pdfBytes = new Uint8Array(this.result);
                currentPdf = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
                uploadView.classList.add('hidden');
                editorView.classList.remove('hidden');
                toolbar.classList.remove('hidden');
                document.getElementById('pageCount').textContent = currentPdf.numPages;
                renderPage(1);
            };
            reader.readAsArrayBuffer(file);
        }

        async function renderPage(num) {
            currentPageNum = num;
            document.getElementById('pageNum').textContent = num;
            const page = await currentPdf.getPage(num);
            const viewport = page.getViewport({ scale: 1.5 });
            pdfCanvas.height = viewport.height;
            pdfCanvas.width = viewport.width;
            drawingLayer.height = viewport.height;
            drawingLayer.width = viewport.width;
            await page.render({ canvasContext: pdfCanvas.getContext('2d'), viewport }).promise;
            if (!pageData[num]) { pageData[num] = []; saveHistory(); }
            selectedElement = null; redrawCanvas(); updateHistoryButtons();
        }

        function drawArrow(ctx, x1, y1, x2, y2, color) {
            const headlen = 15; const angle = Math.atan2(y2 - y1, x2 - x1);
            ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));
            ctx.closePath(); ctx.fillStyle = color; ctx.fill();
        }

        drawingLayer.onmousedown = (e) => {
            const coords = getCanvasCoordinates(e); startX = coords.x; startY = coords.y;
            if (document.querySelector('.text-input-area')) return;
            if (mode === 'select') {
                const hit = findElementWithHandleAt(startX, startY);
                if (hit) { selectedElement = hit.element; dragMode = hit.handle; isMouseDown = true; isDragging = false; }
                else { selectedElement = null; }
                btnDelete.classList.toggle('hidden', !selectedElement); redrawCanvas(); return;
            }
            if (mode === 'text') { addTextInput(startX, startY); return; }
            isMouseDown = true; dragMode = 'move';
            if (mode === 'draw') pageData[currentPageNum].push({ type: 'draw', points: [{ x: startX, y: startY }], color: currentColor });
            else if (mode === 'rect') pageData[currentPageNum].push({ type: 'rect', x: startX, y: startY, w: 0, h: 0, color: currentColor });
            else if (mode === 'arrow' || mode === 'arrowtext') pageData[currentPageNum].push({ type: mode, x: startX, y: startY, x2: startX, y2: startY, color: currentColor, text: '' });
        };

        drawingLayer.onmousemove = (e) => {
            if (!isMouseDown) return;
            const coords = getCanvasCoordinates(e); const currX = coords.x; const currY = coords.y;
            if (mode === 'select' && selectedElement) {
                isDragging = true;
                if (dragMode === 'endpoint') { selectedElement.x2 = currX; selectedElement.y2 = currY; }
                else {
                    const dx = currX - startX; const dy = currY - startY;
                    if (selectedElement.type === 'draw') selectedElement.points.forEach(p => { p.x += dx; p.y += dy; });
                    else if (selectedElement.type === 'arrow' || selectedElement.type === 'arrowtext') { selectedElement.x += dx; selectedElement.y += dy; selectedElement.x2 += dx; selectedElement.y2 += dy; }
                    else { selectedElement.x += dx; selectedElement.y += dy; }
                }
                startX = currX; startY = currY; redrawCanvas(); return;
            }
            const activeObj = pageData[currentPageNum][pageData[currentPageNum].length - 1];
            if (mode === 'draw') activeObj.points.push({ x: currX, y: currY });
            else if (mode === 'rect') { activeObj.w = currX - startX; activeObj.h = currY - startY; }
            else if (mode === 'arrow' || mode === 'arrowtext') { activeObj.x2 = currX; activeObj.y2 = currY; }
            redrawCanvas();
        };

        drawingLayer.onmouseup = () => {
            if (isMouseDown && (mode !== 'select' || isDragging)) {
                const activeObj = pageData[currentPageNum][pageData[currentPageNum].length - 1];
                if (mode === 'arrowtext' && !isDragging) addTextInput(activeObj.x, activeObj.y, activeObj);
                else saveHistory();
            }
            isMouseDown = false; isDragging = false;
        };

        function getArrowTextPoints(el) {
            const lines = (el.text || "").split('\n');
            const h = lines.length * 24 + 8; const w = TEXT_WIDTH;
            const dx = el.x2 - (el.x + w / 2); const dy = el.y2 - (el.y + h / 2);
            let sx, sy;
            if (Math.abs(dx) / w > Math.abs(dy) / h) { sx = (dx > 0) ? el.x + w : el.x; sy = el.y + h / 2; }
            else { sx = el.x + w / 2; sy = (dy > 0) ? el.y + h : el.y; }
            return { x1: sx, y1: sy, x2: el.x2, y2: el.y2 };
        }

        function redrawCanvas() {
            drawCtx.clearRect(0, 0, drawingLayer.width, drawingLayer.height);
            textLayer.innerHTML = '';
            const rect = drawingLayer.getBoundingClientRect();
            const cssScaleX = rect.width / drawingLayer.width;
            const cssScaleY = rect.height / drawingLayer.height;

            pageData[currentPageNum].forEach(el => {
                const isSelected = (el === selectedElement);
                drawCtx.strokeStyle = el.color; drawCtx.lineWidth = 3;
                if (el.type === 'draw') {
                    drawCtx.beginPath(); el.points.forEach((p, i) => i === 0 ? drawCtx.moveTo(p.x, p.y) : drawCtx.lineTo(p.x, p.y)); drawCtx.stroke();
                } else if (el.type === 'rect') drawCtx.strokeRect(el.x, el.y, el.w, el.h);
                else if (el.type === 'arrow') drawArrow(drawCtx, el.x, el.y, el.x2, el.y2, el.color);
                else if (el.type === 'arrowtext') { const pts = getArrowTextPoints(el); drawArrow(drawCtx, pts.x1, pts.y1, pts.x2, pts.y2, el.color); }

                if (el.text) {
                    const div = document.createElement('div');
                    div.style.cssText = `position:absolute;left:${el.x * cssScaleX}px;top:${el.y * cssScaleY}px;width:${TEXT_WIDTH * cssScaleX}px;color:${el.color};font-size:16px;font-family:sans-serif;white-space:pre-wrap;pointer-events:none;font-weight:500;`;
                    div.textContent = el.text;
                    if (isSelected) div.style.outline = '2px dashed #3b82f6';
                    textLayer.appendChild(div);
                }
                if (isSelected) drawSelectionOverlay(el);
            });
        }

        function drawSelectionOverlay(el) {
            drawCtx.save(); drawCtx.setLineDash([8, 4]); drawCtx.strokeStyle = '#3b82f6';
            if (el.x2 !== undefined) {
                drawCtx.setLineDash([]); drawCtx.fillStyle = 'white'; drawCtx.beginPath(); drawCtx.arc(el.x2, el.y2, 6, 0, 7); drawCtx.fill(); drawCtx.stroke();
            }
            drawCtx.restore();
        }

        function findElementWithHandleAt(x, y) {
            const list = pageData[currentPageNum];
            for (let i = list.length - 1; i >= 0; i--) {
                const el = list[i];
                if (el.x2 !== undefined && Math.hypot(el.x2 - x, el.y2 - y) < 20) return { element: el, handle: 'endpoint' };
                if (x > el.x - 10 && x < el.x + TEXT_WIDTH + 10 && y > el.y - 10 && y < el.y + 50) return { element: el, handle: 'move' };
            }
            return null;
        }

        function addTextInput(x, y, targetObj = null) {
            const rect = drawingLayer.getBoundingClientRect();
            const tx = document.createElement('textarea');
            tx.className = 'text-input-area';
            tx.style.left = (x * rect.width / drawingLayer.width) + 'px';
            tx.style.top = (y * rect.height / drawingLayer.height) + 'px';
            tx.style.color = currentColor;
            canvasContainer.appendChild(tx); tx.focus();
            tx.onblur = () => {
                const val = tx.value.trim();
                if (val) {
                    if (targetObj) { targetObj.text = val; }
                    else pageData[currentPageNum].push({ type: 'text', text: val, x, y, color: currentColor });
                    saveHistory(); redrawCanvas();
                }
                tx.remove();
            };
        }

        const btns = { select: 'btnSelect', draw: 'btnDraw', rect: 'btnRect', arrow: 'btnArrow', text: 'btnText', arrowtext: 'btnArrowText' };
        Object.entries(btns).forEach(([k, v]) => document.getElementById(v).onclick = () => {
            mode = k; selectedElement = null; redrawCanvas();
            Object.values(btns).forEach(id => document.getElementById(id).classList.remove('active'));
            document.getElementById(v).classList.add('active');
        });

        document.querySelectorAll('.color-btn').forEach(b => b.onclick = () => {
            currentColor = b.dataset.color;
            document.querySelectorAll('.color-btn').forEach(c => c.classList.remove('active'));
            b.classList.add('active');
        });

        document.getElementById('savePdf').onclick = async () => {
            const { PDFDocument, rgb, StandardFonts } = PDFLib;
            const pdfDoc = await PDFDocument.load(pdfBytes);
            const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
            for (let i = 0; i < pdfDoc.getPages().length; i++) {
                const page = pdfDoc.getPages()[i]; const data = pageData[i+1] || [];
                const { width, height } = page.getSize();
                const sx = width / pdfCanvas.width; const sy = height / pdfCanvas.height;
                data.forEach(el => {
                    const c = el.color.match(/\w\w/g).map(x => parseInt(x, 16)/255);
                    const color = rgb(c[0], c[1], c[2]);
                    if (el.text) page.drawText(el.text, { x: el.x * sx, y: height - el.y * sy - 14, size: 14 * sy, color, font });
                    if (el.type === 'arrow' || el.type === 'arrowtext') {
                        const p = el.type === 'arrow' ? el : getArrowTextPoints(el);
                        page.drawLine({ start: { x: p.x1 * sx, y: height - p.y1 * sy }, end: { x: p.x2 * sx, y: height - p.y2 * sy }, thickness: 2, color });
                    }
                });
            }
            const blob = new Blob([await pdfDoc.save()], { type: 'application/pdf' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = "edited.pdf"; a.click();
        };

        document.getElementById('exportPng').onclick = () => {
            const link = document.createElement('a');
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = pdfCanvas.width;
            tempCanvas.height = pdfCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(pdfCanvas, 0, 0);
            tempCtx.drawImage(drawingLayer, 0, 0);
            link.download = `page_${currentPageNum}.png`;
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        };

        document.getElementById('prevPage').onclick = () => currentPageNum > 1 && renderPage(currentPageNum - 1);
        document.getElementById('nextPage').onclick = () => currentPageNum < currentPdf.numPages && renderPage(currentPageNum + 1);
        btnUndo.onclick = undo; btnRedo.onclick = redo;
        btnDelete.onclick = () => { if (selectedElement) { const list = pageData[currentPageNum]; list.splice(list.indexOf(selectedElement), 1); saveHistory(); selectedElement = null; redrawCanvas(); } };
    </script>
</body>
</html>
